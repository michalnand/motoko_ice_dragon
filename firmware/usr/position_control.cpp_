#include "position_control.h"
#include <drivers.h>
#include <fmath.h>



PositionControl *g_position_control;

#ifdef __cplusplus
extern "C" {
#endif


void TIM7_IRQHandler(void)
{ 
    g_position_control->callback_position();
    TIM_ClearITPendingBit(TIM7, TIM_IT_CC1);  
} 

 
#ifdef __cplusplus
}
#endif


void PositionControl::init()
{
    g_position_control = this;

    //TODO - move this into config.h

    //250Hz sampling rate, 4ms
    uint32_t dt_us = 4000;

    //robot dimensions
    this->wheel_diameter = 34.0*0.001;
    this->wheel_brace    = 80.0*0.001;

    //1200RPM max, to rad/s
    float antiwindup = 1200*2.0*PI/60.0;


    //input shaper ramps
    float du_p = 1.0;
    float du_n = -1.0;

    //init LQR with Kalman observer

    float mat_a[] = {
		0.99998784, -4.165272e-06, 0.40438575, 0.00932306, 
		-0.0022387686, 1.0002357, 3.2722392, 0.24350357, 
		-1.217908e-05, -4.165851e-06, 0.40454173, 0.00932245, 
		-0.0022387677, 0.00023565967, 3.2722385, 0.24350397 };

    float mat_b[] = {
            5.9936603e-05, 2.6422116e-05, 
            -0.0015565199, 0.0010904992, 
            5.9924234e-05, 2.6412128e-05, 
            -0.0015565191, 0.0010904986 };

    float mat_c[] = {
            1.0, 0.0, 0.0, 0.0, 
            0.0, 1.0, 0.0, 0.0 };

    float k[] = {
            31.676172, -6.5725865, -24.707117, -1.9916012, 
            30.022614, 6.5334544, 73.61637, 3.338386 };

    float ki[] = {
            0.07065838, -0.0717278, 
            0.07107809, 0.071294695 };

    float f[] = {
            0.6227735, 0.03759783, 
            0.03759783, 0.9322217, 
            0.012180835, 0.092096195, 
            0.09769884, 0.77118033 };




    //controller init
    lqg.init(mat_a, mat_b, mat_c, k, ki, f, antiwindup);

    //shaper init
    shaper_left.init(du_p, du_n); 
    shaper_right.init(du_p, du_n); 

    //required values init
    this->x     = 0.0;
    this->theta = 0.0;

    /*
    //init timer 7 interrupt for callback calling, 250Hz
    
    TIM_TimeBaseInitTypeDef     TIM_TimeBaseStructure;
    NVIC_InitTypeDef            NVIC_InitStructure;

    
    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);

    TIM_TimeBaseStructure.TIM_Prescaler         = 0;
    TIM_TimeBaseStructure.TIM_CounterMode       = TIM_CounterMode_Up;
    TIM_TimeBaseStructure.TIM_Period            = timer_period(dt_us);
    TIM_TimeBaseStructure.TIM_ClockDivision     = 0; 
    TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;   

    TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure);
    TIM_ITConfig(TIM7, TIM_IT_CC1, ENABLE);
    TIM_Cmd(TIM7, ENABLE);  

    NVIC_InitStructure.NVIC_IRQChannel = TIM7_IRQn;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority    = 4;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority           = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    NVIC_Init(&NVIC_InitStructure);
    */

    
    terminal << "position_control init [DONE]\n";
}

// @param : x : required distance, [m]
// @param : theta : required angle, [rad]
void PositionControl::step(float x, float theta)
{
    this->x     = x;
    this->theta = theta;
}
        
void PositionControl::callback_position()
{
    //fill required values
    lqg.yr[0] = this->x;
    lqg.yr[1] = this->theta;

    //fill current state
    float right_position = motor_control.get_right_position();
    float left_position  = motor_control.get_left_position();

    float distance = 0.5*(right_position + left_position)*wheel_diameter;
    float angle    = (right_position - left_position)*wheel_diameter / wheel_brace;

    lqg.y[0]  = distance;
    lqg.y[1]  = angle;

    //compute controller output
    bool saturation = shaper_left.is_saturated() || shaper_right.is_saturated();
    lqg.step(saturation);

    //output shaping
    float vl_shaped = shaper_left.step(lqg.u[0]); 
    float vr_shaped = shaper_right.step(lqg.u[1]);

    // send to wheel velocity controll
    motor_control.set_velocity(vl_shaped, vr_shaped);
}

